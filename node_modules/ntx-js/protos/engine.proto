syntax = "proto3";

package ntx.v2t.engine;

option go_package = "engine";
option java_package = "cz.ntx.proto.v2t.engine";
option csharp_namespace = "cz.ntx.proto.v2t.engine";

message Event {
  message Timestamp {
    oneof value {
      uint64 timestamp = 1;
      uint64 recovery = 2;
    }
  }

  message Label {
    oneof label {
      string item = 1;
      string plus = 2;
      string noise = 3;
    }
  }

  message Audio {
    bytes body = 1;
    uint64 offset = 5;
    uint64 duration = 6;
  }

  message Meta {
    message Confidence {
      double value = 1;
    }

    oneof body {
      Confidence confidence = 1;
    }
  }

  oneof body {
    Timestamp timestamp = 1;
    Label label = 2;
    Audio audio = 3;
    Meta meta = 4;
  }
}

message Events {
  repeated Event events = 1;
  bool lookahead = 2;
    //client-side processing
  uint64 receivedAt = 3; 
  //client-side processing
  uint32 channelId = 4;

}

enum EngineModule {
  MODULE_NONE = 0;
  MODULE_VAD = 1;
  MODULE_V2T = 5;
  MODULE_PPC = 11;
}

message Lexicon {

  enum Alphabet {
    LEXICON_ALPHABET_NONE = 0;
    LEXICON_ALPHABET_CZ48 = 1;
    LEXICON_ALPHABET_SK48 = 2;
    LEXICON_ALPHABET_HR39 = 3;
    LEXICON_ALPHABET_SL39 = 4;
    LEXICON_ALPHABET_PL42 = 5;
  }

  message UserItem {
    //output symbol
    string sym = 1;
    //pronunciation
    string pron = 2;
  }

  message NoiseItem {
    //output symbol
    string sym = 1;
    //pronunciation
    string pron = 2;
  }

  message MainItem {
    //output symbol
    string sym = 1;
    //pronunciation
    string pron = 2;
    //mount, equal to sym if blank
    string mnt = 3;
  }

  message LexItem {
    oneof item {
      UserItem user = 1;
      MainItem main = 2;
      NoiseItem noise = 3;
    }
  }

  Alphabet alpha = 1;
  repeated LexItem items = 2;
}

message AudioFormat {

  enum ChannelLayout {
    AUDIO_CHANNEL_LAYOUT_NONE = 0;
    AUDIO_CHANNEL_LAYOUT_MONO = 1;
    AUDIO_CHANNEL_LAYOUT_STEREO = 2;
  }

  enum SampleFormat {
    AUDIO_SAMPLE_FORMAT_NONE = 0;
    AUDIO_SAMPLE_FORMAT_ALAW = 1;
    AUDIO_SAMPLE_FORMAT_F32BE = 2;
    AUDIO_SAMPLE_FORMAT_F32LE = 3;
    AUDIO_SAMPLE_FORMAT_F64BE = 4;
    AUDIO_SAMPLE_FORMAT_F64LE = 5;
    AUDIO_SAMPLE_FORMAT_MULAW = 6;
    AUDIO_SAMPLE_FORMAT_S16BE = 7;
    AUDIO_SAMPLE_FORMAT_S16LE = 8;
    AUDIO_SAMPLE_FORMAT_S24BE = 9;
    AUDIO_SAMPLE_FORMAT_S24LE = 10;
    AUDIO_SAMPLE_FORMAT_S32BE = 11;
    AUDIO_SAMPLE_FORMAT_S32LE = 12;
    AUDIO_SAMPLE_FORMAT_S8 = 13;
    AUDIO_SAMPLE_FORMAT_U16BE = 14;
    AUDIO_SAMPLE_FORMAT_U16LE = 15;
    AUDIO_SAMPLE_FORMAT_U24BE = 16;
    AUDIO_SAMPLE_FORMAT_U24LE = 17;
    AUDIO_SAMPLE_FORMAT_U32BE = 18;
    AUDIO_SAMPLE_FORMAT_U32LE = 19;
    AUDIO_SAMPLE_FORMAT_U8 = 20;
  }

  enum SampleRate {
    AUDIO_SAMPLE_RATE_NONE = 0;
    AUDIO_SAMPLE_RATE_8000 = 1;
    AUDIO_SAMPLE_RATE_16000 = 2;
    AUDIO_SAMPLE_RATE_32000 = 3;
    AUDIO_SAMPLE_RATE_48000 = 4;
    AUDIO_SAMPLE_RATE_96000 = 5;
    AUDIO_SAMPLE_RATE_11025 = 6;
    AUDIO_SAMPLE_RATE_22050 = 7;
    AUDIO_SAMPLE_RATE_44100 = 8;
  }

  message AutoDetect {
    //probing size in bytes (from 32 to INT_MAX)
    uint32 probeSizeBytes = 1;
  }

  message PCM {
    SampleFormat sampleFormat = 1;
    SampleRate sampleRate = 2;
    ChannelLayout channelLayout = 3;
  }

  message Header {
    bytes header = 1;
  }

  oneof formats {
    AutoDetect auto = 1;
    PCM pcm = 2;
    Header header = 3;
  }
}

message EngineContext {

  message VADConfig {
  }

  message V2TConfig {
    VADConfig withVAD = 1;
    PPCConfig withPPC = 3;
    Lexicon withLexicon = 4;
  }

  message PPCConfig {
  }

  enum AudioChannel {
    AUDIO_CHANNEL_DOWNMIX = 0;
    AUDIO_CHANNEL_LEFT = 1;
    AUDIO_CHANNEL_RIGHT = 2;
  }

  AudioFormat audioFormat = 1;
  AudioChannel audioChannel = 2;

  oneof config {
    VADConfig vad = 3;
    V2TConfig v2t = 5;
    PPCConfig ppc = 9;
  }
}

message EngineContextStart {
  EngineContext context = 1;
}

message EngineContextEnd {
  string error = 1;
}

message EventsPush {
  Events events = 1;
}

message EventsPull {
}

message EngineStream {
  oneof payload {
    EngineContextStart start = 1;
    EventsPush push = 2;
    EventsPull pull = 3;
    EngineContextEnd end = 4;
  }
}

service EngineService {
  rpc StreamingRecognize (stream EngineStream) returns (stream EngineStream);
}